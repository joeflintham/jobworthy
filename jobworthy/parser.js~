var events = require('events');
var error = '';

var parser = function(obj, callback){
    this.obj = obj;
    this.callback = callback;
    events.EventEmitter.call(this);

    this.parse = function(){
	var id, data, nodes, self = this;
		
	try {	

	if (!this.obj) throw new Error('Missing an object to parse!');
	    
	    
	    id = this.obj.id, data = this.obj.data, nodes = this.obj.nodes;
	    if (!id) throw new Error('Missing a selector / node id to reference');
	    if (data.length > 0) data.forEach(function(e,i,a){
		var attrObj = this.dataProp(e, function(err){
		    console.log("Caught an error in the context of " + obj.id + "; ");console.log(err);
		});

		for (var dp in attrObj){
		    if (attrObj[dp] != ''){
			self.emit('dataProp', [obj.id, attrObj])
		    }
		}
	    },
	    this);
	    
	} catch (e) {
	    if (callback) callback(e, !!0)
	}
    }

    this.dataProp = function(dataProps, callback){
	// expects e to be an array with two or more members
	var offset, props, attrName='', attrValue='';
	if (dataProps.length > 0) offset = dataProps.shift();
	if (dataProps.length > 0) props = dataProps.shift();
	
	if (!offset || !props) { return }
	attrName = "data-" + offset;
	
	props.forEach(function(prop){
	    attrValue += prop[0] + ":" + prop[1] + ";";    
	});
	
	
	if (!attrName || !attrValue) { if (callback) callback(new Error('Unable to parse data properties')); return };
	rv = {}; rv[attrName] = attrValue;
	return rv;
	
    }
    
    if (this.callback) this.callback(error, this);
}

parser.prototype.__proto__ = events.EventEmitter.prototype;
exports.parser = parser
